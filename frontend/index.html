<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Board ‚Äî –ø—Ä–æ—Ç–æ—Ç–∏–ø</title>
<style>
  :root{
    --bg:#0f1720;
    --panel:#0b1220;
    --accent:#7c3aed;
    --muted:#9aa4b2;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family:Inter,Segoe UI,Arial;}
  .app{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}
  .left{width:72px;display:flex;flex-direction:column;align-items:center;gap:12px}
  .palette{width:64px;height:64px;border-radius:50%;position:relative;display:flex;align-items:center;justify-content:center}
  .swatch{position:absolute;width:18px;height:18px;border-radius:50%;box-shadow:0 2px 6px rgba(0,0,0,.6);cursor:pointer;border:2px solid rgba(255,255,255,.08)}
  .controls{display:flex;flex-direction:column;gap:8px;align-items:center}
  button{background:var(--panel);border:1px solid rgba(255,255,255,.04);color:var(--muted);padding:6px 8px;border-radius:8px;cursor:pointer}
  .status{font-size:12px;color:var(--muted);margin-top:6px;text-align:center}
  .main{flex:1;display:flex;flex-direction:column;background:linear-gradient(180deg,#07101a, #05101a);border-radius:8px;padding:8px;box-shadow:0 6px 30px rgba(2,6,23,.6)}
  .toolbar{display:flex;gap:8px;align-items:center;padding:6px 8px}
  .canvas-wrap{flex:1;position:relative;overflow:hidden;border-radius:6px;background:#07121a;display:flex;align-items:center;justify-content:center}
  canvas{background:transparent;display:block}
  .hint{position:absolute;left:8px;bottom:8px;background:rgba(0,0,0,.4);padding:6px 8px;border-radius:6px;font-size:13px;color:var(--muted)}
  #wrap {
  touch-action: none;
  overscroll-behavior: none;
}
.modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  align-items: center;
  justify-content: center;
  z-index: 9999;
}
.modal-content {
  background: #1b2230;
  padding: 16px 20px;
  border-radius: 10px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  color: #e6eef6;
  min-width: 240px;
}
.modal-content h3 {
  margin: 0 0 10px;
  font-size: 16px;
  text-align: center;
}
.modal-content label {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin: 4px 0;
  font-size: 13px;
}
.modal-content input[type="range"] {
  flex: 1;
  margin-left: 8px;
}
.preview {
  width: 100%;
  height: 40px;
  border-radius: 6px;
  margin-bottom: 10px;
  border: 1px solid rgba(255,255,255,0.1);
}
.modal-buttons {
  display: flex;
  justify-content: space-between;
  margin-top: 10px;
}
.modal-buttons button {
  flex: 1;
  margin: 0 4px;
  background: var(--panel);
  color: var(--muted);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 6px;
  padding: 6px;
  cursor: pointer;
}
.modal-buttons button:hover {
  background: var(--accent);
  color: #fff;
}

</style>
</head>
<body>
<div class="app">
  <div class="left">
    <div class="palette" id="palette"></div>
    <div class="controls">
      <button id="zoomIn">+</button>
      <button id="zoomOut">‚àí</button>
      <button id="erase">–õ–∞—Å—Ç–∏–∫</button>
      <button id="colorPickerBtn">–¶–≤–µ—Ç</button>
    </div>
    <div class="status" id="status">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
  </div>

  <div class="main">
    <div class="toolbar">
      <div>–ü–æ–ª–æ—Ç–Ω–æ: <strong id="boardSize">10000√ó10000</strong></div>
      <div style="flex:1"></div>
      <div>–ú–∞—Å—à—Ç–∞–±: <span id="scaleLabel">8</span>x</div>
    </div>

    <div class="canvas-wrap" id="wrap">
      <canvas id="c"></canvas>
      <div class="hint">–ö–æ–ª–µ—Å–æ ‚Äî –∑—É–º, –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞—Ç—å ‚Äî –ø–∞–Ω. –ö–ª–∏–∫ ‚Äî –∑–∞–∫—Ä–∞—Å–∏—Ç—å</div>
    </div>
  </div>
</div>

<!-- —Å–∫—Ä—ã—Ç—ã–π native color input –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ü–≤–µ—Ç–∞ -->
<!-- –¥–µ–ª–∞–µ–º –Ω–µ–≤–∏–¥–∏–º—ã–º, –Ω–æ –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–º -->
<input type="color" id="nativeColor"
  style="position:fixed;opacity:0;width:0;height:0;border:none;padding:0;margin:0;">



<script>
/* ===========================
   –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
   =========================== */
const LOGICAL_WIDTH = 10000;
const LOGICAL_HEIGHT = 10000;

const canvas = document.getElementById('c');
const wrap = document.getElementById('wrap');
const statusEl = document.getElementById('status');
const scaleLabel = document.getElementById('scaleLabel');
const boardSizeEl = document.getElementById('boardSize');
boardSizeEl.textContent = LOGICAL_WIDTH + '√ó' + LOGICAL_HEIGHT;

/* Viewport / transforms */
let scale = 8;                // —Å–∫–æ–ª—å–∫–æ –ø–∏–∫—Å–µ–ª–µ–π –≤ —ç–∫—Ä–∞–Ω–µ –∑–∞–Ω–∏–º–∞–µ—Ç 1 –ª–æ–≥–∏—á–µ—Å–∫–∏–π –ø–∏–∫—Å–µ–ª—å (–Ω–∞—á–∞–ª—å–Ω—ã–π)
const MIN_SCALE = 0.5;
const MAX_SCALE = 40;
let offsetX = -(LOGICAL_WIDTH/2) * scale +  (window.innerWidth/2);
let offsetY = -(LOGICAL_HEIGHT/2) * scale + (window.innerHeight/2);

let dragging = false;
let dragStart = null;

let needsRedraw = true;

/* Pixel storage: sparse map key = "x,y" -> color (hex) */
const pixels = new Map();

/* –í—ã–±—Ä–∞–Ω–Ω—ã–π —Ü–≤–µ—Ç */
let currentColor = '#ff3b30';
let eraseMode = false;

/* –°–µ—Ç–µ–≤—ã–µ (WebSocket) */
let ws = null;
const WS_URL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws'; // –ø—Ä–∏–º–µ—Ä; –Ω–∞ –±—ç–∫–µ –º–æ–∂–Ω–æ —Å–ª—É—à–∞—Ç—å /ws
let connected = false;

/* Canvas size to match container */
function resizeCanvas(){
  canvas.width = wrap.clientWidth;
  canvas.height = wrap.clientHeight;
  needsRedraw = true;
}
window.addEventListener('resize', resizeCanvas);

/* ===========================
   –ü–∞–ª–∏—Ç—Ä–∞ ‚Äî –∫—Ä—É–≥–æ–≤–æ–π —Ä–∞—Å–∫–ª–∞–¥
   =========================== */
const paletteEl = document.getElementById('palette');
const presetColors = [
  '#000000','#7f7f7f','#ffffff','#ff3b30','#ff9500',
  '#ffd60a','#32d74b','#30d5c8','#0a84ff','#5e5ce6',
  '#af52de','#ff2d55'
];

// —Ä–∞–∑–º–µ—Å—Ç–∏–º –∫–æ–ª—å—Ü–æ–º
function buildPalette(){
  const r = 26; // —Ä–∞–¥–∏—É—Å
  const cx = 32, cy = 32;
  const n = presetColors.length;
  presetColors.forEach((col,i)=>{
    const ang = (i / n) * Math.PI * 2 - Math.PI/2;
    const x = cx + Math.cos(ang) * r;
    const y = cy + Math.sin(ang) * r;
    const sw = document.createElement('div');
    sw.className = 'swatch';
    sw.style.left = (x - 9) + 'px';
    sw.style.top = (y - 9) + 'px';
    sw.style.background = col;
    sw.title = col;
    sw.addEventListener('click', ()=>{ currentColor = col; eraseMode = false; updateUI(); });
    paletteEl.appendChild(sw);
  });
}
buildPalette();

/* native color picker */
const nativeColor = document.getElementById('nativeColor');
const colorBtn = document.getElementById('colorPickerBtn');
const eraseBtn = document.getElementById('erase');

colorBtn.addEventListener('click', () => {
  nativeColor.value = currentColor;   // –ø–µ—Ä–µ–¥–∞—ë–º —Ç–µ–∫—É—â–∏–π —Ü–≤–µ—Ç
  nativeColor.click();                // –≤—ã–∑—ã–≤–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–π –≤—ã–±–æ—Ä —Ü–≤–µ—Ç–∞
});

nativeColor.addEventListener('input', (e) => {
  currentColor = e.target.value;
  eraseMode = false;
  colorBtn.style.backgroundColor = currentColor; // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ü–≤–µ—Ç –Ω–∞ –∫–Ω–æ–ø–∫–µ
  updateUI();
});

eraseBtn.addEventListener('click', () => {
  eraseMode = !eraseMode;
  updateUI();
});


/* –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ */
function updateUI() {
  document.querySelectorAll('.swatch').forEach(s => s.style.outline = '');
  paletteEl.style.boxShadow = eraseMode
    ? 'inset 0 0 0 3px rgba(255,255,255,.06)'
    : 'none';
  
  // üîπ –≤–∏–∑—É–∞–ª—å–Ω—ã–π –æ—Ç–∫–ª–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ª–∞—Å—Ç–∏–∫"
  eraseBtn.style.backgroundColor = eraseMode ? '#333' : '';
  eraseBtn.style.color = eraseMode ? '#fff' : '';
}


/* ===========================
   WebSocket: init / updates
   =========================== */
function connectWS(){
  ws = new WebSocket(WS_URL);
  ws.addEventListener('open', ()=> {
    connected = true;
    statusEl.textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–æ';
    // –∑–∞–ø—Ä–æ—Å–∏–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é, –µ—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –Ω–µ —à–ª—ë—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    ws.send(JSON.stringify({type:'init_request'}));
  });
  ws.addEventListener('message', ev => {
    try{
      const msg = JSON.parse(ev.data);
      handleServerMessage(msg);
    }catch(e){ console.error('ws parse', e); }
  });
  ws.addEventListener('close', ()=> {
    connected = false;
    statusEl.textContent = '–û—Ç–∫–ª—é—á–µ–Ω–æ, –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞—é—Å—å...';
    setTimeout(connectWS, 1500);
  });
  ws.addEventListener('error', ()=> {
    statusEl.textContent = '–û—à–∏–±–∫–∞ WebSocket';
  });
}
connectWS();

/* –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞ */
function handleServerMessage(msg){
  if(!msg || !msg.type) return;
  if(msg.type === 'init'){
    // –æ–∂–∏–¥–∞–µ–º: {type:'init', width, height, pixels: [{x,y,color}, ...]}
    if(msg.width && msg.height){
      // –µ—Å–ª–∏ —Ä–∞–∑–º–µ—Ä—ã –æ—Ç–ª–∏—á–∞—é—Ç—Å—è ‚Äî –º–æ–∂–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å; —Ç—É—Ç —Ñ–∏–∫—Å–∏—Ä—É–µ–º –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã (10000√ó10000)
      // –∑–∞–≥—Ä—É–∂–∞–µ–º –ø–∏–∫—Å–µ–ª–∏
    }
    if(Array.isArray(msg.pixels)){
      // –∑–∞–º–µ–Ω—è–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é Map (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ) ‚Äî –Ω–æ –ª—É—á—à–µ merge
      msg.pixels.forEach(p => {
        const key = p.x + ',' + p.y;
        pixels.set(key, p.color);
      });
      needsRedraw = true;
    }
    statusEl.textContent = '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ';
  } else if(msg.type === 'pixel_update'){
    // –æ–¥–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∏–ª–∏ –º–∞—Å—Å–∏–≤
    if(Array.isArray(msg.pixels)){
      msg.pixels.forEach(p => {
        const key = p.x + ',' + p.y;
        if(p.color === null) pixels.delete(key);
        else pixels.set(key, p.color);
      });
    } else if(typeof msg.x !== 'undefined'){
      const key = msg.x + ',' + msg.y;
      if(msg.color === null) pixels.delete(key);
      else pixels.set(key, msg.color);
    }
    needsRedraw = true;
  } else if(msg.type === 'bulk'){
    // –µ—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –ø—Ä–∏—Å–ª–∞–ª –±–æ–ª—å—à–æ–π batched update
    if(Array.isArray(msg.ops)){
      msg.ops.forEach(o => {
        const key = o.x + ',' + o.y;
        if(o.color === null) pixels.delete(key);
        else pixels.set(key, o.color);
      });
      needsRedraw = true;
    }
  }
}

/* –û—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–∏–∫—Å–µ–ª—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä */
function sendSetPixel(x,y,color){
  if(!connected || !ws) return;
  const msg = { type:'set_pixel', x, y, color }; // color=null –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
  ws.send(JSON.stringify(msg));
}

/* ===========================
   –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞
   =========================== */
function screenToCanvas(px, py){
  // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (—Ü–µ–ª—ã–µ –ø–∏–∫—Å–µ–ª–∏)
  const x = Math.floor((px - offsetX) / scale);
  const y = Math.floor((py - offsetY) / scale);
  return {x, y};
}

function canvasToScreen(x, y){
  // –∏–∑ –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –≤ —ç–∫—Ä–∞–Ω–Ω—ã–µ
  return { px: x * scale + offsetX, py: y * scale + offsetY };
}

/* Draw loop */
const ctx = canvas.getContext('2d');

function draw(){
  if(!needsRedraw) return;
  needsRedraw = false;
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  // background grid fill
  ctx.fillStyle = '#07121a';
  ctx.fillRect(0,0,w,h);

  // visible logical bounds
  const left = Math.floor((-offsetX) / scale);
  const top  = Math.floor((-offsetY) / scale);
  const right = Math.ceil((w - offsetX) / scale);
  const bottom = Math.ceil((h - offsetY) / scale);

  // clamp to board
  const sx = Math.max(0, left);
  const sy = Math.max(0, top);
  const ex = Math.min(LOGICAL_WIDTH-1, right);
  const ey = Math.min(LOGICAL_HEIGHT-1, bottom);

  // draw pixels from our map that intersect visible area
  // iterate through Map keys may be large; better approach: iterate visible area if scale reasonably large
  // We'll choose heuristic: if visible area pixel count < 200k iterate area, else iterate Map and check bounds
  const visibleCount = (ex - sx + 1) * (ey - sy + 1);
  if(visibleCount <= 200000){
    // draw by scanning visible coords
    for(let y = sy; y <= ey; y++){
      for(let x = sx; x <= ex; x++){
        const key = x + ',' + y;
        const col = pixels.get(key);
        if(col){
          const sxpx = Math.round(x * scale + offsetX);
          const sypy = Math.round(y * scale + offsetY);
          // avoid hairline artifacts
          ctx.fillStyle = col;
          ctx.fillRect(sxpx, sypy, Math.ceil(scale), Math.ceil(scale));
        }
      }
    }
  } else {
    // iterate map
    for(const [key,col] of pixels){
      const [xStr,yStr] = key.split(',');
      const x = +xStr, y = +yStr;
      if(x < sx || x > ex || y < sy || y > ey) continue;
      const sxpx = Math.round(x * scale + offsetX);
      const sypy = Math.round(y * scale + offsetY);
      ctx.fillStyle = col;
      ctx.fillRect(sxpx, sypy, Math.ceil(Math.max(scale,1)), Math.ceil(Math.max(scale,1)));
    }
  }

  // optionally draw grid at larger scales
  if(scale >= 6){
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    // vertical lines
    const startX = Math.floor(sx);
    const endX = Math.ceil(ex);
    for(let x = startX; x <= endX; x++){
      const sxpx = Math.round(x * scale + offsetX) + 0.5;
      ctx.beginPath();
      ctx.moveTo(sxpx, 0);
      ctx.lineTo(sxpx, h);
      ctx.stroke();
    }
    // horizontal
    const startY = Math.floor(sy);
    const endY = Math.ceil(ey);
    for(let y = startY; y <= endY; y++){
      const sypy = Math.round(y * scale + offsetY) + 0.5;
      ctx.beginPath();
      ctx.moveTo(0, sypy);
      ctx.lineTo(w, sypy);
      ctx.stroke();
    }
  }

  // draw viewport border (optional)
  // ...
}

/* Animation loop */
function loop(){
  if(needsRedraw) draw();
  requestAnimationFrame(loop);
}
resizeCanvas();
needsRedraw = true;
loop();

/* ===========================
   Input: –º—ã—à—å, —Ç–∞—á–ø–∞–¥, —Å–µ–Ω—Å–æ—Ä + –∫–Ω–æ–ø–∫–∏/–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ (—Ñ–∏–Ω–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è –±–µ–∑ MIN/MAX)
   =========================== */

let lastDown = null;
let lastTouchDistance = null;
let isTouchPanning = false;
let touchStartMid = null;

/* --- –ö–æ—Ä—Ä–µ–∫—Ü–∏—è —Å–º–µ—â–µ–Ω–∏–π –ø—Ä–∏ –∫—Ä–∞—è—Ö --- */
function clampOffsets() {
  const boardW = LOGICAL_WIDTH * scale;
  const boardH = LOGICAL_HEIGHT * scale;

  if (boardW <= canvas.width) {
    offsetX = (canvas.width - boardW) / 2;
  } else {
    offsetX = Math.max(canvas.width - boardW, Math.min(0, offsetX));
  }

  if (boardH <= canvas.height) {
    offsetY = (canvas.height - boardH) / 2;
  } else {
    offsetY = Math.max(canvas.height - boardH, Math.min(0, offsetY));
  }
}

/* --- –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —É—á—ë—Ç–æ–º –∫—É—Ä—Å–æ—Ä–∞ + –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –º–∞—Å—à—Ç–∞–±–∞ --- */
function zoomAt(screenX, screenY, factor) {
  const worldX = (screenX - offsetX) / scale;
  const worldY = (screenY - offsetY) / scale;

  let newScale = scale * factor;
  newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
  if (Math.abs(newScale - scale) < 1e-6) return;

  offsetX = screenX - worldX * newScale;
  offsetY = screenY - worldY * newScale;
  scale = newScale;

  clampOffsets();
  needsRedraw = true;

  // üîπ –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –º–∞—Å—à—Ç–∞–±–∞, –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç
  const label = document.getElementById('scaleLabel');
  if (label) {
    label.textContent = `${Math.round(scale * 100)}`;
  }
}


/* --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–ª–µ—Å–∞ –∏ pinch –Ω–∞ —Ç—Ä–µ–∫–ø–∞–¥–µ --- */
function handleWheel(ev) {
  ev.preventDefault();
  const rect = wrap.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;

  let factor;
  if (ev.ctrlKey) factor = 1 - ev.deltaY * 0.01;
  else factor = ev.deltaY < 0 ? 1.12 : 1 / 1.12;
  if (Math.abs(factor - 1) < 0.001) factor = 1 + Math.sign(-ev.deltaY) * 0.05;

  zoomAt(mx, my, factor);
}

wrap.addEventListener('wheel', handleWheel, { passive: false });

/* --- –ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ –º—ã—à—å—é --- */
wrap.addEventListener('mousedown', (ev) => {
  if (ev.button !== 0) return;
  dragging = true;
  dragStart = { x: ev.clientX, y: ev.clientY, ox: offsetX, oy: offsetY };
});
window.addEventListener('mousemove', (ev) => {
  if (dragging && dragStart) {
    offsetX = dragStart.ox + (ev.clientX - dragStart.x);
    offsetY = dragStart.oy + (ev.clientY - dragStart.y);
    clampOffsets();
    needsRedraw = true;
  }
});
window.addEventListener('mouseup', () => (dragging = false));

/* --- –°–µ–Ω—Å–æ—Ä: pan –∏ pinch --- */
wrap.addEventListener('touchstart', (ev) => {
  if (ev.touches.length === 1) {
    isTouchPanning = true;
    const t = ev.touches[0];
    touchStartMid = { x: t.clientX, y: t.clientY, ox: offsetX, oy: offsetY };
    lastTouchDistance = null;
  } else if (ev.touches.length === 2) {
    isTouchPanning = false;
    const [t1, t2] = ev.touches;
    lastTouchDistance = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    touchStartMid = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
  }
}, { passive: false });

wrap.addEventListener('touchmove', (ev) => {
  ev.preventDefault();
  if (ev.touches.length === 1 && isTouchPanning && touchStartMid) {
    const t = ev.touches[0];
    offsetX = touchStartMid.ox + (t.clientX - touchStartMid.x);
    offsetY = touchStartMid.oy + (t.clientY - touchStartMid.y);
    clampOffsets();
    needsRedraw = true;
  } else if (ev.touches.length === 2 && lastTouchDistance != null) {
    const [t1, t2] = ev.touches;
    const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    const factor = dist / lastTouchDistance;
    const rect = wrap.getBoundingClientRect();
    const midX = (t1.clientX + t2.clientX) / 2 - rect.left;
    const midY = (t1.clientY + t2.clientY) / 2 - rect.top;
    zoomAt(midX, midY, factor);
    lastTouchDistance = dist;
  }
}, { passive: false });

wrap.addEventListener('touchend', () => {
  isTouchPanning = false;
  lastTouchDistance = null;
});

/* --- –ö–ª–∏–∫ –ø–æ –ø–∏–∫—Å–µ–ª—é --- */
wrap.addEventListener('pointerdown', (e) => {
  lastDown = { x: e.clientX, y: e.clientY, time: Date.now() };
});
wrap.addEventListener('pointerup', (e) => {
  if (!lastDown) return;
  const dx = Math.abs(e.clientX - lastDown.x);
  const dy = Math.abs(e.clientY - lastDown.y);
  const dt = Date.now() - lastDown.time;
  if (dx < 6 && dy < 6 && dt < 600) {
    const rect = wrap.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    const { x, y } = screenToCanvas(px, py);
    if (x < 0 || x >= LOGICAL_WIDTH || y < 0 || y >= LOGICAL_HEIGHT) return;
    const color = eraseMode ? null : currentColor;
    const key = x + ',' + y;
    if (color === null) pixels.delete(key);
    else pixels.set(key, color);
    needsRedraw = true;
    sendSetPixel(x, y, color);
  }
  lastDown = null;
});

/* --- –ö–ª–∞–≤–∏—à–∏ –∏ –∫–Ω–æ–ø–∫–∏ --- */
window.addEventListener('keydown', (e) => {
  const rect = wrap.getBoundingClientRect();
  if (e.key === '+' || e.key === '=') zoomAt(rect.width / 2, rect.height / 2, 1.2);
  if (e.key === '-') zoomAt(rect.width / 2, rect.height / 2, 1 / 1.2);
});

document.getElementById('zoomIn')?.addEventListener('click', () => {
  const rect = wrap.getBoundingClientRect();
  zoomAt(rect.width / 2, rect.height / 2, 1.2);
});
document.getElementById('zoomOut')?.addEventListener('click', () => {
  const rect = wrap.getBoundingClientRect();
  zoomAt(rect.width / 2, rect.height / 2, 1 / 1.2);
});

/* --- –û—Ç–∫–ª—é—á–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ pinch-to-zoom --- */
wrap.style.touchAction = 'none';
wrap.style.overscrollBehavior = 'none';


/* UI zoom buttons */
document.getElementById('zoomIn').addEventListener('click', ()=> zoomAt(canvas.width/2, canvas.height/2, 1.2));
document.getElementById('zoomOut').addEventListener('click', ()=> zoomAt(canvas.width/2, canvas.height/2, 1/1.2));

/* –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å WebSocket */
setInterval(()=> {
  if(!connected) statusEl.textContent = '–û—Ç–∫–ª—é—á–µ–Ω–æ';
}, 3000);

// ===== –ö–ê–°–¢–û–ú–ù–û–ï –û–ö–ù–û –í–´–ë–û–†–ê –¶–í–ï–¢–ê =====
const customColorBtn = document.getElementById('colorPickerBtn');
const colorModal = document.getElementById('colorModal');
const colorPreview = document.getElementById('colorPreview');
const rRange = document.getElementById('rRange');
const gRange = document.getElementById('gRange');
const bRange = document.getElementById('bRange');
const colorOk = document.getElementById('colorOk');
const colorCancel = document.getElementById('colorCancel');

function hexToRgb(hex){
  const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return m ? {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)} : {r:255,g:255,b:255};
}
function rgbToHex(r,g,b){
  return "#" + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
}

function openColorModal(){
  const rgb = hexToRgb(currentColor);
  rRange.value = rgb.r;
  gRange.value = rgb.g;
  bRange.value = rgb.b;
  colorPreview.style.backgroundColor = currentColor;
  colorModal.style.display = 'flex';
}
function closeColorModal(){
  colorModal.style.display = 'none';
}
function updatePreview(){
  const r = +rRange.value, g = +gRange.value, b = +bRange.value;
  const hex = rgbToHex(r,g,b);
  colorPreview.style.backgroundColor = hex;
}

rRange.addEventListener('input', updatePreview);
gRange.addEventListener('input', updatePreview);
bRange.addEventListener('input', updatePreview);

customColorBtn.addEventListener('click', openColorModal);
colorCancel.addEventListener('click', closeColorModal);
colorOk.addEventListener('click', () => {
  const r = +rRange.value, g = +gRange.value, b = +bRange.value;
  currentColor = rgbToHex(r,g,b);
  customColorBtn.style.backgroundColor = currentColor;
  eraseMode = false;
  updateUI();
  closeColorModal();
});

</script>
<!-- –ö–∞—Å—Ç–æ–º–Ω–æ–µ –æ–∫–Ω–æ –≤—ã–±–æ—Ä–∞ —Ü–≤–µ—Ç–∞ -->
<div id="colorModal" class="modal">
  <div class="modal-content">
    <h3>–í—ã–±–æ—Ä —Ü–≤–µ—Ç–∞</h3>
    <div class="preview" id="colorPreview"></div>
    <label>R: <input type="range" id="rRange" min="0" max="255"></label>
    <label>G: <input type="range" id="gRange" min="0" max="255"></label>
    <label>B: <input type="range" id="bRange" min="0" max="255"></label>
    <div class="modal-buttons">
      <button id="colorOk">–û–ö</button>
      <button id="colorCancel">–û—Ç–º–µ–Ω–∞</button>
    </div>
  </div>
</div>

</body>
</html>
